
h1. General guidelines

All new code (except GUI) should be covered with tests.

h1. Simlib 

h2. General description.

h3. Singletons

Most of the services are provided as singletons. Singletons initialized and deinitialized in sim.cpp:main().
In future, we should get rid of singletons.

h4. EventHub

An event delivery facility. It is based on qt signals/slots. An object can subscribe one of his slots for
given event, and if anyone triggers this event, the slot will be called.

h4. Events framework

In order to trigger event one should call EventHub::triggerEvent(event_name, event_parameters (optional)), where
event_name - String id of the event to trigger
event_parameters - QSharedPointer to subclass of appropriate EventData. Each registered event has it's own EventData subclass.

In order to create a new event one should:
1) Create an EventData subclass with static method "create" which takes all parameters that should be passed to the event
listener and returns a QSharedPointer to the newly created instance of this subclass.

2) Create an IEvent subclass, define a signal, which will be emitted on event trigger, with arbitrary signature and
override "connectTo" and "triggered" methods to match the signature of the signal. (See sim/events/logevent.{h,cpp})

3) Register event using EventHub::registerEvent.

To subscribe on event one should:
1) Obtain a pointer to IEvent subclass using EventHub::getEvent

2) Call "connectTo" method of this subclass to connect the "eventTriggered" signal of this subclass to needed slot.

h4. MessagePipe

Every input message goes through input message pipe. Pipe processes input message using all registered MessageProcessors.
MessageProcessor defines 'process()' method which returns either MessageProcessor::Success or MessageProcessor::Block.
This return value determines, should the processing continue. An example of MessageProcessor would be spam-filter
which will return MessageProcessor::Block on spam messages.  

h4. MessageOutPipe

Similar to MessagePipe, except that it's for outgoing messages.

h4. ImageStorage

This subsystem provides means to retrieve images by string id from registered IconSets.
ImageStorage doesn't do loading images, it is being done by IconSet.

h4. CommandHub

Probably should be heavily reworked.

h4. ContactList

A metacontact(Contact) storage.

h4. ProtocolManager

Provides a storage for Protocol objects. Every protocol plugin should register its Protocol object in ProtocolManager.
There should be only one Protocol for every IM-protocol.

h4. PluginManager

Plugin loading/unloading facility. Needs rework.

h4. ClientManager

Client object represents protocol client. ClientManager is the managing facility for Clients.

h4. HistoryStorage

h4. ProfileManager

Profile is the set of clients, contacts, plugin and contact settings. ProfileManager manages Profile objects.

h3. Contact/Group framework

Contact represents metacontact, i.e. various IM contacts belonging to the same person.
Group represents metagroup.
IMContact represents a concrete IM contact which has associated id (ICQ123456, jabber_id@jabber.com, etc)
Contact may contain several IMContacts.
We should understand also how to handle things like jabber resources. Previous SIM approach was unacceptable.

h3. Networking framework

h1. Core plugin

h2. General description

h3. UI

h3. Roster

h3. Container


h1. Icq plugin

h2. General description

h3. ICQRequestManager

All icq-requests to server should be performed using ICQRequestManager. Therefore, for each request type there should be ICQRequest subclass.
The reasons for introducing ICQRequestManager are following:

# Reduction of coupling between SnacHandlers.
# Request frequency regulation. ICQRequestManager should send requests according to rate limit settings.

== Things to change ==

